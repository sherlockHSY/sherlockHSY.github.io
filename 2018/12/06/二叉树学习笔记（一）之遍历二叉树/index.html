<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>二叉树学习笔记（一）之遍历二叉树 | sherlockyang's blog</title><meta name="description" content="本文主要总结了二叉树的四种遍历方法以及所对应的递归与非递归实现方式。"><meta name="keywords" content="二叉树"><meta name="author" content="sherlockyang"><meta name="copyright" content="sherlockyang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/imgs/myfavicon.png"><link rel="canonical" href="http://example.com/2018/12/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="二叉树学习笔记（一）之遍历二叉树"><meta property="og:url" content="http://example.com/2018/12/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"><meta property="og:site_name" content="sherlockyang's blog"><meta property="og:description" content="本文主要总结了二叉树的四种遍历方法以及所对应的递归与非递归实现方式。"><meta property="og:image" content="http://example.com/imgs/avatar.jpg"><meta property="article:published_time" content="2018-12-06T15:17:40.000Z"><meta property="article:modified_time" content="2020-09-03T14:26:58.688Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: {"limitCount":50,"languages":{"author":"作者: sherlockyang","link":"链接: ","source":"来源: sherlockyang's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-03 22:26:58'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/imgs/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">二叉树基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.2.</span> <span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.</span> <span class="toc-text">满二叉树与完全二叉树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.</span> <span class="toc-text">顺序存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.2.</span> <span class="toc-text">链式存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A6%96%E5%85%88%E6%9D%A5%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8B%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.</span> <span class="toc-text">首先来认识一下遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.</span> <span class="toc-text">先序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">递归遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">非递归遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.3.</span> <span class="toc-text">中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">递归遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">非递归遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.4.</span> <span class="toc-text">后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86-2"><span class="toc-number">3.4.1.</span> <span class="toc-text">递归遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86-2"><span class="toc-number">3.4.2.</span> <span class="toc-text">非递归遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">3.5.</span> <span class="toc-text">层次遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">3.5.1.</span> <span class="toc-text">使用队列的非递归遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.6.</span> <span class="toc-text">遍历的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6"><span class="toc-number">3.6.1.</span> <span class="toc-text">求二叉树深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E8%AE%A1%E6%95%B0"><span class="toc-number">3.6.2.</span> <span class="toc-text">叶子节点计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.6.3.</span> <span class="toc-text">销毁二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E7%BB%93%E7%82%B9%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-number">3.6.4.</span> <span class="toc-text">删除指定元素结点的子树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.6.5.</span> <span class="toc-text">复制二叉树</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">sherlockyang's blog</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">二叉树学习笔记（一）之遍历二叉树</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-12-06T15:17:40.000Z" title="发表于 2018-12-06 23:17:40">2018-12-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-03T14:26:58.688Z" title="更新于 2020-09-03 22:26:58">2020-09-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>15分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><blockquote>
<p>前言 </p>
<p>考试月了，得好好学习下数据结构，本文主要总结了二叉树的四种遍历方法以及所对应的递归与非递归实现方式</p>
</blockquote>
<h1 id="二叉树基础知识"><a href="#二叉树基础知识" class="headerlink" title="二叉树基础知识"></a>二叉树基础知识</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>二叉树定义：含有n（n&gt;=0）个节点的有限集合</li>
<li>非空二叉树中：<ul>
<li>有且仅有一个根节点</li>
<li>其余节点划分为两个互不相交的子集L和R，L称为左子树，R称为右子树</li>
</ul>
</li>
<li>任一结点的左、右子树的根称为该结点的左、右孩子，反过来，该结点称为孩子的双亲</li>
<li>度：结点的孩子个数</li>
<li>叶子结点：度为0 的结点</li>
<li>非叶子结点：度大于0，也称为内部结点或分支结点</li>
<li>二叉树的深度（或高度）：结点的最大层次称为二叉树的深度（或高度）。（所谓层次，根节点即为第一层，以此类推）</li>
</ul>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ol>
<li>在非空二叉树的第 i 层上最多右 2^(i-1) 个结点（i&gt;=1）</li>
<li>深度为 k 的二叉树最多有 2^k - 1 个结点（k&gt;=1）</li>
<li>对于任意一颗二叉树，如果度为 0 的结点个数为 n0 ,度为 2 的结点个数为   n2，则 n0 = n2+1</li>
<li>具有 n 个结点的完全二叉树的深度 k = [log2n] + 1</li>
<li>对于含 n 个结点的完全二叉树中编号为 i (1&lt;=i&lt;=n) 的结点<ol>
<li>如果 i = 1，则 i 结点是这颗完全二叉树的根，没有双亲；否则其双亲的编号为 [i/2]</li>
<li>如果 2i&gt;n，则 i 结点没有左孩子；否则其左孩子的编号为 2i</li>
<li>如果 2i+1&gt;n，则 i 结点没有右孩子；否则其右孩子的编号为 2i+1</li>
</ol>
</li>
</ol>
<h2 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h2><ul>
<li><p><strong>满二叉树</strong>：深度为 k 且有 2^k - 1 个结点的二叉树</p>
</li>
<li><p><strong>完全二叉树</strong>：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。深度为K且含 n 个结点的二叉树，如果其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应，则称之为完全二叉树。换句话讲，在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。</p>
<p><img src="https://i.loli.net/2018/12/07/5c0952c618ebb.png" alt=""></p>
</li>
</ul>
<h1 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h1><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维数组实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;	  <span class="comment">// 假设结点元素类型为字符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">TElemType * elem;	      <span class="comment">// 0号单元闲置</span></span><br><span class="line"><span class="keyword">int</span> lastIndex;		      <span class="comment">// 二叉树最后一个结点的编号</span></span><br><span class="line">&#125; SqBiTree;</span><br></pre></td></tr></table></figure>
<h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><ul>
<li>二叉链表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;	  				<span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>	<span class="comment">// 左、右孩子指针域</span></span><br><span class="line">&#125; BiTNode,*BiTNode;</span><br></pre></td></tr></table></figure>
<ul>
<li>三叉链表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span>&#123;</span></span><br><span class="line">    TElemType data;	  						<span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">parent</span>,*<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">// 双亲左、右孩子指针域</span></span><br><span class="line">&#125; TriTNode,*TriTNode;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="首先来认识一下遍历"><a href="#首先来认识一下遍历" class="headerlink" title="首先来认识一下遍历"></a>首先来认识一下遍历</h2><p><strong>遍历</strong>：树的遍历（也称为树的搜索）是图的遍历的一种，指的是按照某种规则，不重复地访问某种树的所有结点，使得每个结点被且仅被访问的过程。具体的访问操作可能是检查节点的值、更新节点的值等。二叉树的遍历也适用于其它树的遍历。</p>
<p>遍历是二叉树的一类重要操作，也是二叉树的其他一些操作和各种应用算法的基本框架。</p>
<p>遍历有两种类别，一种是深度优先遍历，另一种是广度优先遍历</p>
<ul>
<li><p>深度优先遍历：先访问子节点，再访问父节点，最后是第二个子节点</p>
<ul>
<li>先序遍历：VLR，即根结点-&gt;左结点-&gt;右节点</li>
<li>中序遍历：LVR，即左结点-&gt;根结点-&gt;右节点</li>
<li>后序遍历：LRV，即左结点-&gt;右结点-&gt;根节点</li>
</ul>
</li>
<li><p>广度优先遍历：先访问第一个子节点，再访问第二个子节点，最后访问父节点，二叉树的广度优先遍历就是层次遍历</p>
</li>
</ul>
<p><img src="https://i.loli.net/2018/12/11/5c0fb4f0b1258.jpg" alt="遍历.jpg"></p>
<p>由于从给定的某个节点出发，有多个可以前往的下一个节点（树不是线性数据结构），所以在顺序计算（即非并行计算）的情况下，只能推迟对某些节点的访问——即以某种方式保存起来以便稍后再访问。常见的做法是采用栈（LIFO）或队列（FIFO）。由于树本身是一种自我引用（即递归定义）的数据结构，因此很自然也可以用递归方式。</p>
<p>所以，下面我重点总结了这两种不同的遍历实现方式。</p>
<p>注：本文所讲的数据结构均为C语言版</p>
<h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T,Status(*visit)(TElemType e))</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">NULL</span> == T) <span class="keyword">return</span> OK;</span><br><span class="line">   <span class="keyword">if</span>(ERROR == visit(T-&gt;data))</span><br><span class="line">       <span class="keyword">return</span> ERROR; <span class="comment">//访问结点的数据域</span></span><br><span class="line">   <span class="keyword">if</span>(ERROR == PreOrderTraverse(T-&gt;lchild,visit))</span><br><span class="line">       <span class="keyword">return</span> ERROR; <span class="comment">//递归遍历T的左子树</span></span><br><span class="line">   <span class="keyword">return</span> PreOrderTraverse(T-&gt;rchild,visit);<span class="comment">//递归遍历T的右子树</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><p><strong>1.使用栈的非递归先序遍历算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">二叉链表类型定义：</span></span><br><span class="line"><span class="comment">typedef struct BiTNode &#123;</span></span><br><span class="line"><span class="comment">  TElemType  data;</span></span><br><span class="line"><span class="comment">  struct BiTNode  *lchild,*rchild;</span></span><br><span class="line"><span class="comment">&#125; BiTNode, *BiTree;</span></span><br><span class="line"><span class="comment">栈类型Stack的相关定义：</span></span><br><span class="line"><span class="comment">typedef BiTree SElemType;   	      // 栈的元素类型</span></span><br><span class="line"><span class="comment">Status InitStack(Stack &amp;S); 	      // 初始化栈</span></span><br><span class="line"><span class="comment">Status StackEmpty(Stack S); 	      // 判栈空</span></span><br><span class="line"><span class="comment">Status Push(Stack &amp;S, SElemType e);	  // 进栈</span></span><br><span class="line"><span class="comment">Status Pop(Stack &amp;S, SElemType &amp;e);   // 出栈 </span></span><br><span class="line"><span class="comment">Status GetTop(Stack S, SElemType &amp;e); // 取栈顶元素</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T, <span class="keyword">void</span> (*visit)(TElemType))</span></span></span><br><span class="line"><span class="function"><span class="comment">/*对每个结点的元素域data调用函数visit进行访问 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Stack S;   InitStack(S);</span><br><span class="line">   BiTree p = T;</span><br><span class="line">   <span class="comment">// 先序访问根节点，遍历左节点 ，左节点入栈</span></span><br><span class="line">   <span class="comment">// StackEmpty(Stack S);S为空返回true反之false;</span></span><br><span class="line">   <span class="comment">// 当栈不空或 p非空时</span></span><br><span class="line">   <span class="keyword">while</span>(!StackEmpty(S) || p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">     <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(p-&gt;data);</span><br><span class="line">        Push(S,p);</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(!StackEmpty(S))&#123;</span><br><span class="line">        Pop(S,p); <span class="comment">// 执行完 p指向S出栈的元素</span></span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/12/10/5c0e83640eff5.jpg" alt="先序遍历.jpg"></p>
<p><strong>2.不使用栈，使用三叉链表的非递归先序遍历算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********  </span></span><br><span class="line"><span class="comment">三叉链表类型定义：  </span></span><br><span class="line"><span class="comment">typedef struct TriTNode &#123;  </span></span><br><span class="line"><span class="comment">	TElemType data;  </span></span><br><span class="line"><span class="comment">	struct TriTNode *parent, *lchild, *rchild;  </span></span><br><span class="line"><span class="comment">&#125; TriTNode, *TriTree;  </span></span><br><span class="line"><span class="comment">**********/</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T, <span class="keyword">void</span> (*visit)(TElemType))</span></span>&#123;</span><br><span class="line">    TriTree p, pr;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = T;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            visit(p-&gt;data);<span class="comment">//输出当前的结点</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                p = p-&gt;lchild;<span class="comment">//若有左孩子，继续访问</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                p = p-&gt;rchild;<span class="comment">//若有右孩子，继续访问</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">//沿双亲指针链查找，找到第一个由右孩子的p结点</span></span><br><span class="line">              <span class="comment">//找不到则结束</span></span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    pr = p;</span><br><span class="line">                    p = p-&gt;parent;</span><br><span class="line">                &#125;<span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;(p-&gt;rchild==pr||<span class="literal">NULL</span>==p-&gt;rchild)) <span class="comment">//p有右孩子但不是pr，结束循环</span></span><br><span class="line">            	<span class="keyword">if</span>(p) p = p-&gt;rchild;<span class="comment">//找到后，p指向右孩子结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归遍历-1"><a href="#递归遍历-1" class="headerlink" title="递归遍历"></a>递归遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T,Status(*visit)(TElemType e))</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">NULL</span> == T) <span class="keyword">return</span> OK;</span><br><span class="line">   <span class="keyword">if</span>(ERROR == InOrderTraverse(T-&gt;lchild,visit))</span><br><span class="line">       <span class="keyword">return</span> ERROR; <span class="comment">//递归遍历T的左子树</span></span><br><span class="line">   <span class="keyword">if</span>(ERROR == visit(T-&gt;data))</span><br><span class="line">       <span class="keyword">return</span> ERROR; <span class="comment">//访问结点的数据域</span></span><br><span class="line">   <span class="keyword">return</span> InOrderTraverse(T-&gt;rchild,visit);<span class="comment">//递归遍历T的右子树</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历-1"><a href="#非递归遍历-1" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><p><strong>1.使用栈的非递归中序遍历算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">二叉链表类型定义：</span></span><br><span class="line"><span class="comment">typedef struct BiTNode &#123;</span></span><br><span class="line"><span class="comment">  TElemType  data;</span></span><br><span class="line"><span class="comment">  struct BiTNode  *lchild,*rchild;</span></span><br><span class="line"><span class="comment">&#125; BiTNode, *BiTree;</span></span><br><span class="line"><span class="comment">栈类型Stack的相关定义：</span></span><br><span class="line"><span class="comment">typedef BiTree SElemType;   	      // 栈的元素类型</span></span><br><span class="line"><span class="comment">Status InitStack(Stack &amp;S); 	      // 初始化栈</span></span><br><span class="line"><span class="comment">Status StackEmpty(Stack S); 	      // 判栈空</span></span><br><span class="line"><span class="comment">Status Push(Stack &amp;S, SElemType e);	  // 进栈</span></span><br><span class="line"><span class="comment">Status Pop(Stack &amp;S, SElemType &amp;e);   // 出栈 </span></span><br><span class="line"><span class="comment">Status GetTop(Stack S, SElemType &amp;e); // 取栈顶元素</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function">BiTNode *<span class="title">GoFarLeft</span><span class="params">(BiTree T,Stack &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从T结点出发，沿左分支走到底，沿途结点的指针入栈S，返回左上结点的指针</span></span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(T-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        Push(S,T);</span><br><span class="line">        T = T-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T,<span class="keyword">void</span>(*visit)(TElemType e))</span></span>&#123;</span><br><span class="line">    Stack S;   InitStack(S);</span><br><span class="line">    BiTree p；</span><br><span class="line">    p = GoFarLeft(T, S);<span class="comment">//找到最左下的结点，并将沿途结点的指针入栈S</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(p-&gt;data);<span class="comment">//访问结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//令p指向其右孩子为根的子树的最左下结点</span></span><br><span class="line">            p = GoFarLeft(p-&gt;rchild, S);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!StackEmpty(S))&#123;</span><br><span class="line">            <span class="comment">//栈不空时退栈</span></span><br><span class="line">            Pop(S,p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = <span class="literal">NULL</span>;<span class="comment">//栈空表明遍历结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/12/11/5c0e8f9080dbe.jpg" alt="中序遍历.jpg"></p>
<p><strong>2.不使用栈，使用三叉链表的非递归中序遍历算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********  </span></span><br><span class="line"><span class="comment">三叉链表类型定义：  </span></span><br><span class="line"><span class="comment">typedef struct TriTNode &#123;  </span></span><br><span class="line"><span class="comment">	TElemType data;  </span></span><br><span class="line"><span class="comment">	struct TriTNode *parent, *lchild, *rchild;  </span></span><br><span class="line"><span class="comment">&#125; TriTNode, *TriTree;  </span></span><br><span class="line"><span class="comment">**********/</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(TriTree PT, <span class="keyword">void</span> (*visit)(TElemType))</span></span>&#123;</span><br><span class="line">	TriTree p=PT, pr;  </span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">NULL</span> != p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            p = p-&gt;lchild;   <span class="comment">//寻找最左下结点</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            visit(p-&gt;data);</span><br><span class="line">            <span class="comment">//当前节点左子树为空，但右子树不一定为空，</span></span><br><span class="line">            <span class="comment">//所以该节点可能是这个子树的根节点，要先访问，</span></span><br><span class="line">            <span class="comment">//如果有右节点，才能在右节点之前访问</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">                <span class="comment">//若有右子树，转到该子树，继续寻找最左下结点</span></span><br><span class="line">                p =p-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">//执行到这里</span></span><br><span class="line">                <span class="comment">//p 要不是最左下节点，要不是没有孩子的右节点</span></span><br><span class="line">                <span class="comment">//其实也就是叶子节点</span></span><br><span class="line">                pr = p;    <span class="comment">//否则返回其父亲</span></span><br><span class="line">                p = p-&gt;parent;  </span><br><span class="line">                <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; (p-&gt;lchild != pr || <span class="literal">NULL</span> == p-&gt;rchild))<span class="comment">//若其不是从左子树回溯来的，或左结点的父亲并没有右孩子 </span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;lchild == pr) &#123;<span class="comment">//若最左结点的父亲并没有右孩子         </span></span><br><span class="line">                    	visit(p-&gt;data);<span class="comment">//直接访问父亲</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    pr = p;  <span class="comment">//父亲已被访问，故返回上一级</span></span><br><span class="line">                    p = p-&gt;parent;  </span><br><span class="line">                <span class="comment">//该while循环沿双亲链一直查找，若无右孩子则访问</span></span><br><span class="line">                <span class="comment">//直至找到第一个有右孩子的结点为止</span></span><br><span class="line">                <span class="comment">//（但不访问该结点，留给下步if语句访问</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != p) &#123;</span><br><span class="line">                 <span class="comment">//访问父亲，并转到右孩子</span></span><br><span class="line">                 <span class="comment">//（经上步while处理，可以确定此时p有右孩子）</span></span><br><span class="line">                    visit(p-&gt;data);</span><br><span class="line">                    p = p-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归遍历-2"><a href="#递归遍历-2" class="headerlink" title="递归遍历"></a>递归遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T,Status(*visit)(TElemType e))</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="literal">NULL</span> == T) <span class="keyword">return</span> OK;</span><br><span class="line">   <span class="keyword">if</span>(ERROR == PostOrderTraverse(T-&gt;lchild,visit))</span><br><span class="line">       <span class="keyword">return</span> ERROR; <span class="comment">//递归遍历T的左子树</span></span><br><span class="line">   <span class="keyword">if</span>(ERROR == PostOrderTraverse(T-&gt;rchild,visit))</span><br><span class="line">       <span class="keyword">return</span> ERROR; <span class="comment">//递归遍历T的右子树</span></span><br><span class="line">   <span class="keyword">return</span> visit(T-&gt;data);<span class="comment">//访问结点的数据域</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历-2"><a href="#非递归遍历-2" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><p><strong>1.使用栈的非递归后序遍历算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">二叉链表类型定义：</span></span><br><span class="line"><span class="comment">typedef struct BiTNode &#123;</span></span><br><span class="line"><span class="comment">  TElemType  data;</span></span><br><span class="line"><span class="comment">  struct BiTNode  *lchild,*rchild;</span></span><br><span class="line"><span class="comment">&#125; BiTNode, *BiTree;</span></span><br><span class="line"><span class="comment">为分辨后序遍历时两次进栈的不同返回点，需在指针进栈时同时将一个标志进栈</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">  struct BiTNode *ptr; // 二叉树结点的指针类型</span></span><br><span class="line"><span class="comment">  int  tag; 		   // 标志 值为 0 或 1</span></span><br><span class="line"><span class="comment">&#125; SElemType;    	   // 栈的元素类型</span></span><br><span class="line"><span class="comment">栈类型Stack的相关定义：</span></span><br><span class="line"><span class="comment">typedef BiTree SElemType;   	      // 栈的元素类型</span></span><br><span class="line"><span class="comment">Status InitStack(Stack &amp;S); 	      // 初始化栈</span></span><br><span class="line"><span class="comment">Status StackEmpty(Stack S); 	      // 判栈空</span></span><br><span class="line"><span class="comment">Status Push(Stack &amp;S, SElemType e);	  // 进栈</span></span><br><span class="line"><span class="comment">Status Pop(Stack &amp;S, SElemType &amp;e);   // 出栈 </span></span><br><span class="line"><span class="comment">Status GetTop(Stack S, SElemType &amp;e); // 取栈顶元素</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T, <span class="keyword">void</span> (*visit)(TElemType))</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 使用栈，非递归后序遍历二叉树T，     */</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 对每个结点的元素域data调用函数visit */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S; InitStack(S); </span><br><span class="line">    SElemType e; BiTree p=T;</span><br><span class="line">    e.tag=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>((!StackEmpty(S)||p==T)&amp;&amp;T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;<span class="comment">// 这个小 while循环的目的是先遍历每个子树的左节点到底，并将沿途的左节点入栈</span></span><br><span class="line">            e.ptr=p;</span><br><span class="line">            e.tag=<span class="number">0</span>;</span><br><span class="line">            Push(S,e); <span class="comment">// 入栈</span></span><br><span class="line">            p=p-&gt;lchild;                        </span><br><span class="line">        &#125;<span class="comment">// 小while结束，此时的栈顶元素也就是要访问的起始节点      </span></span><br><span class="line">        <span class="keyword">if</span>(!StackEmpty(S))&#123;  <span class="comment">// tag==1，e为第二次出现在栈顶</span></span><br><span class="line">            Pop(S,e); <span class="comment">// 取出栈顶元素，并返回给e,e指向出栈元素，方便下面的tag值判断</span></span><br><span class="line">            <span class="keyword">if</span>(e.tag == <span class="number">1</span>)  &#123;</span><br><span class="line">                p=e.ptr;</span><br><span class="line">                visit(p-&gt;data);<span class="comment">// 访问该结点 </span></span><br><span class="line">                p = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  &#123;                </span><br><span class="line">                p=e.ptr;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;rchild)&#123;  <span class="comment">// 如果存在右子树，设tag == 1</span></span><br><span class="line">                    e.tag=<span class="number">1</span>;</span><br><span class="line">                    Push(S,e); <span class="comment">// 重新入栈，它是根节点，留着等下再访问</span></span><br><span class="line">                    p=p-&gt;rchild;  <span class="comment">// 使 p指向右子树</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;<span class="comment">//没有右子树 ，直接访问该节点</span></span><br><span class="line">                    p=e.ptr;</span><br><span class="line">                    visit(p-&gt;data);</span><br><span class="line">                    p = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//栈空则 p为NULL</span></span><br><span class="line">            p=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//大while结束        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/12/11/5c0fb2a144cbe.jpg" alt="后序遍历.jpg"></p>
<p><strong>2.不使用栈，使用三叉链表的非递归后序遍历算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********  </span></span><br><span class="line"><span class="comment">在三叉链表的结点中增设一个标志域  (mark取值0,1或2)以区分遍历过程中到达该结点时应继续向左或向右或访问该结点</span></span><br><span class="line"><span class="comment">带标志域的三叉链表类型定义：  </span></span><br><span class="line"><span class="comment">typedef struct TriTNode &#123;  </span></span><br><span class="line"><span class="comment">	TElemType data;  </span></span><br><span class="line"><span class="comment">	struct TriTNode *lchild, *rchild, *parent;  </span></span><br><span class="line"><span class="comment">	int mark; // 标志域  </span></span><br><span class="line"><span class="comment">&#125; TriTNode, *TriTree;  </span></span><br><span class="line"><span class="comment">**********/</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(TriTree T, <span class="keyword">void</span> (*visit)(TElemType))</span>  </span></span><br><span class="line"><span class="function"><span class="comment">/* 不使用栈，非递归后序遍历二叉树T， */</span>  </span></span><br><span class="line"><span class="function"><span class="comment">/* 对每个结点的元素域data调用函数visit */</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//mark ==  0 向左访问，1 访问自身，2 向右访问  </span></span><br><span class="line">    TriTree p= T, pr;  </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> ; </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;  </span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;mark!=<span class="number">1</span>)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>) <span class="comment">//若有右孩子  </span></span><br><span class="line">                p-&gt;mark=<span class="number">2</span>;  </span><br><span class="line">            <span class="keyword">else</span> p-&gt;mark=<span class="number">1</span>;  </span><br><span class="line">            pr=p; </span><br><span class="line">            p=p-&gt;lchild;  </span><br><span class="line">        &#125;  </span><br><span class="line">        p=pr; <span class="comment">// p为最左下节点，可能有右孩子</span></span><br><span class="line">        pr=pr-&gt;parent;  </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;mark==<span class="number">2</span>)  &#123; <span class="comment">// p有右孩子</span></span><br><span class="line">            p-&gt;mark=<span class="number">1</span>; <span class="comment">// p访问完右边后下次要访问自己 </span></span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>&#123;  </span><br><span class="line">            visit(p-&gt;data); <span class="comment">// 访问</span></span><br><span class="line">            p-&gt;mark=<span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==T-&gt;data)  <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><p>层次遍历是按二叉树的层次从小到大且每层从左到右的顺序依次访问结点</p>
<p>对于顺序存储结构的二叉树，其结点在数组中的顺序下标序列与层次遍历的访问顺序一致，因此可直接根据数组得到层次遍历的结果。</p>
<p>对于链式存储结构的二叉树，难以获得结点的同一层的下一层结点，从层末结点也难以得到下一层的层首结点。所以可使用一个辅助队列存储当前层被访问过的结点。</p>
<h3 id="使用队列的非递归遍历"><a href="#使用队列的非递归遍历" class="headerlink" title="使用队列的非递归遍历"></a>使用队列的非递归遍历</h3><p>算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">二叉链表类型定义：</span></span><br><span class="line"><span class="comment">typedef struct BiTNode &#123;</span></span><br><span class="line"><span class="comment">  TElemType  data;</span></span><br><span class="line"><span class="comment">  struct BiTNode  *lchild,*rchild;</span></span><br><span class="line"><span class="comment">&#125; BiTNode, *BiTree;</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(BiTree T,Status(*visit)(TEleType e))</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        Queue Q; 	InitQueue(Q);</span><br><span class="line">        BiTree p = T; <span class="comment">//初始化</span></span><br><span class="line">        visit(p-&gt;data); <span class="comment">//访问根节点</span></span><br><span class="line">        EnQueue(Q,p); <span class="comment">//并将根节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(OK==DeQueue(Q,p))<span class="comment">//当队非空时重复执行出队操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)<span class="comment">//访问左孩子并入队</span></span><br><span class="line">        &#123;</span><br><span class="line">        	visit(p-&gt;lchild-&gt;data);</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)<span class="comment">//访问右孩子并入队</span></span><br><span class="line">        &#123;</span><br><span class="line">            visit(p-&gt;rchild-&gt;data);</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历的应用"><a href="#遍历的应用" class="headerlink" title="遍历的应用"></a>遍历的应用</h2><h3 id="求二叉树深度"><a href="#求二叉树深度" class="headerlink" title="求二叉树深度"></a>求二叉树深度</h3><p>利用后序遍历框架递归求左、右子树深度，然后取两者的较大值加 1（根节点）作为深度值返回。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTreeDepth</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depthLeft,depthRight;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span>==T) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//二叉树深度为0</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        depthLeft = BiTreeDepth(T-&gt;lchild);</span><br><span class="line">        depthRight = BiTreeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+((depthLeft&gt;depthRight)?depthLeft:depthRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="叶子节点计数"><a href="#叶子节点计数" class="headerlink" title="叶子节点计数"></a>叶子节点计数</h3><p>利用先序遍历框架递归实现，算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountLeaf</span><span class="params">(BiTree T, <span class="keyword">int</span> &amp;count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == T-&gt;lchild &amp;&amp; <span class="literal">NULL</span> == T-&gt;rchild)&#123;</span><br><span class="line">            count++;  <span class="comment">// 对叶子结点计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        CountLeaf(T-&gt;lchild, count); <span class="comment">// 对左子树递归计数</span></span><br><span class="line">        CountLeaf(T-&gt;rchild, count); <span class="comment">// 对右子树递归计数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="销毁二叉树"><a href="#销毁二叉树" class="headerlink" title="销毁二叉树"></a>销毁二叉树</h3><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        DestroyBiTree(T-&gt;lchild);<span class="comment">// 递归销毁左子树</span></span><br><span class="line">        DestroyBiTree(T-&gt;rchild);<span class="comment">// 递归销毁右子树</span></span><br><span class="line">        <span class="built_in">free</span>(T);				 <span class="comment">// 释放根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除指定元素结点的子树"><a href="#删除指定元素结点的子树" class="headerlink" title="删除指定元素结点的子树"></a>删除指定元素结点的子树</h3><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReleaseX</span><span class="params">(BiTree &amp;T, <span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 对于二叉树T中每一个元素值为x的结点， */</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 删去以它为根的子树，并释放相应的空间 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> ;</span><br><span class="line">    ReleaseX(T-&gt;lchild,x);</span><br><span class="line">    ReleaseX(T-&gt;rchild,x);</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data == x) <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复制二叉树"><a href="#复制二叉树" class="headerlink" title="复制二叉树"></a>复制二叉树</h3><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CopyBiTree</span><span class="params">(BiTree T, BiTree &amp;TT)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 递归复制二叉树T得到TT */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   TT = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">   <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        TT-&gt;data = T-&gt;data;</span><br><span class="line">        TT-&gt;lchild = T-&gt;lchild;</span><br><span class="line">        TT-&gt;rchild = T-&gt;rchild;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;lchild) CopyBiTree(T-&gt;lchild,TT-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;rchild)CopyBiTree(T-&gt;rchild,TT-&gt;rchild);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>  <span class="built_in">free</span>(TT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">sherlockyang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2018/12/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/">http://example.com/2018/12/06/二叉树学习笔记（一）之遍历二叉树/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">sherlockyang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a></div><div class="post_share"><div class="social-share" data-image="/imgs/avatar.jpg" data-sites="twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2018/12/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E5%A0%86/"><img class="prev-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">二叉树学习笔记（二）之堆</div></div></a></div><div class="next-post pull-right"><a href="/2018/11/06/matlab%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"><img class="next-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">matlab学习小结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2018/12/08/二叉树学习笔记（二）之堆/" title="二叉树学习笔记（二）之堆"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-12-08</div><div class="title">二叉树学习笔记（二）之堆</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC80MDQxMS8xNjkzOA=="></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By sherlockyang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">一花一剑一壶酒，不负光阴不负卿</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>